# Reflection: Assignment 3
## Object-Oriented Redesign of ETL Pipeline

**Author:** Sumayia Moore
**Package:** org.howard.edu.lsp.assignment3

---

## Overview

In Assignment 2, I built a complete ETL pipeline in a single Java class called ETLPipeline.java. While the program worked correctly, all logic — reading the CSV, applying transformations, handling errors, and writing output — was written inside one long main method. Assignment 3 asked me to redesign that solution using object-oriented principles to produce cleaner, more maintainable code.

---

## What Is Different About the Design?

In Assignment 2, everything lived in one class with one main method. There were no objects, no encapsulation of data, and no separation of responsibilities. If I needed to change the transformation logic, I had to dig through the same method that also handled file reading and writing.

In Assignment 3, the code is split across five files:

- Product.java — represents a single product with private fields and public getters/setters
- FileHandler.java — an abstract base class for file operations
- CSVReader.java — extends FileHandler, responsible only for reading and parsing the CSV
- ProductTransformer.java — responsible only for applying transformations
- ETLPipeline.java — the main class that coordinates the three steps

Each class has one clear job. This is called the Single Responsibility Principle, and it makes the code much easier to read, test, and modify.

---

## How Is Assignment 3 More Object-Oriented?

**1. Objects instead of raw arrays**
In Assignment 2, each product was stored as a String array. I had to remember that index 0 was the ID, index 1 was the name, and so on. In Assignment 3, each product is a Product object with named fields. This is much clearer and less error-prone.

**2. Encapsulation**
The Product class uses private fields and public getters/setters to control access to its data. No other class can directly modify a product's fields without going through the defined methods. This protects the integrity of the data.

**3. Inheritance**
CSVReader extends the abstract class FileHandler. FileHandler defines the shared filePath field and an abstract process() method. CSVReader inherits the file path management and provides its own implementation of process(). If a CSVWriter class were added in the future, it would also extend FileHandler and inherit the same foundation.

**4. Abstraction**
FileHandler is abstract — it defines what a file handler should do without implementing the details. This forces subclasses to provide their own specific behavior.

---

## OO Concepts Used

| Concept       | Where Applied                                          |
|---------------|--------------------------------------------------------|
| Encapsulation | Product.java — private fields, public getters/setters  |
| Inheritance   | CSVReader extends FileHandler                          |
| Abstraction   | FileHandler is abstract with an abstract process()     |
| Object        | Each CSV row becomes a Product object                  |
| Class         | Five classes each with a single responsibility         |

---

## How I Tested Assignment 3

To confirm Assignment 3 produces identical output to Assignment 2, I ran both programs using the same data/products.csv file provided in the assignment.

Both programs produced the following console output:

    === ETL Pipeline Run Summary ===
    Rows read (non-header):  12
    Rows transformed:        7
    Rows skipped:            5
    Output written to:       data/transformed_products.csv

Both also produced identical transformed_products.csv output:

    ProductID,Name,Price,Category,PriceRange
    7,USB CABLE,8.99,Electronics,Low
    8,OFFICE CHAIR,150.00,Furniture,High
    9,4K TV,1080.00,Premium Electronics,Premium
    10,GIFT CARD,10.00,Other,Low
    11,MOUSE,23.00,Electronics,Medium
    12,TABLE,500.00,Furniture,High
    13,CAMERA,500.40,Premium Electronics,Premium

I also tested the missing input file case and confirmed Assignment 3 prints a clear error message and exits cleanly, matching Assignment 2 behavior.

---

## Conclusion

Assignment 3 is a significant improvement over Assignment 2 in terms of design. The code is more readable, each class has a single clear responsibility, and the use of encapsulation and inheritance makes the program easier to extend in the future. The behavior and output are identical to Assignment 2, confirming that the redesign was successful.

